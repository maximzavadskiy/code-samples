assert = require 'assert'
should = require 'should'

#globals from commonSetup, will be initialized in before()
client = {}
DB_UPDATE_WAIT = 0
PAGE_LOAD_WAIT = 0

describe "#7 As a boss I want to specify how much and what should a worker produce at a specific time in a day", ->
	@timeout 100000 # TODO change back to 10s

	testBaseUrl = '/admin/batches' 

	newBatch = 
		productionTime: 10
		productionDays: ['mon','tue','wed','thu','fri']
		name: 'Soft Batch'
		products: # will be autogenerated
			4 : [5, 4, 1, 200] # lifetime : howmany, howmmany..
			6 : [1, 2, 3, 1]
			12 : [20, 100, 6, 17]

	#all products, contains more than newBatch
	newProductInfos = 
		4 : [] # lifetime : howmany, howmmany..
		6 : []
		12 : []
	
	getTilePath = (name) ->
		return "//*[text()[contains(.,\"#{name}\")]]/ancestor::div[contains(@class,\"admin-item-tile\")]"

	getProductItemPaths = (lifetime, index, productInfo) ->
		lifetimeGroupPath = "//h1[text()[contains(.,\"#{lifetime}\")]]/../div[contains(@class,'batch-product-group')]"
		selectPath = "#{lifetimeGroupPath}/descendant::select[#{index+1}]"
		productItemGroupPath = "#{selectPath}/.."

		return {
			controlsGroup : lifetimeGroupPath
			addBtn : "#{lifetimeGroupPath}/button[contains(@class, 'btn-add')]"
			selectInput : 	selectPath
			validOptionInput :	"#{selectPath}/option[@value='#{productInfo?.productId or ''}']"
			currentOptionInput: "#{selectPath}/option[@selected]"
			amountInput :	"#{productItemGroupPath}/descendant::input[contains(@class, 'edit-batch-product-amount')]"
			deleteBtn : "#{productItemGroupPath}/descendant::button[contains(@class, 'btn-exclude')]"
		}
						


	forEachProductInNewBatch = (onEach) ->
		for lifetime, productInfos of newBatch.products
			for productInfo, index in productInfos
				onEach 	productInfo,
					parseInt(lifetime),
					index
					
	before (done)->
		client = @client
		DB_UPDATE_WAIT = @DB_UPDATE_WAIT
		PAGE_LOAD_WAIT = @PAGE_LOAD_WAIT

		#console.log 'in before() @DB_UPDATE_WAIT=',@DB_UPDATE_WAIT

		client

		.addCommand 'clickButtonOnBatch', (byName, buttonClass, callback) ->
			tilePath = getTilePath byName
			client.waitFor tilePath, 1000
			.moveToObject tilePath
			.buttonClick "#{tilePath}/descendant::*[contains(@class,\"#{buttonClass}\")]", (err) ->
				should.not.exist err
				callback? err, true

		.addCommand 'gotoEditBatch', (byName, callback) ->
			client.clickButtonOnBatch byName, 'btn-tile-edit', (err) ->
				client.pause PAGE_LOAD_WAIT, -> #allow for animation to finish
					callback? err, true

		.addCommand 'saveBatch', (callback) ->
			client.buttonClick "#btn-save"
			.pause @DB_UPDATE_WAIT
			#.saveScreenshot 'beforeAlertAccept.png'
			.customAlertAccept()
			.call callback

		.addCommand 'fillNewBatchForm', (callback) ->
			client
			.buttonClick "#btn-goto-create-new-batch"

			.click '#input-production-time'
			.click "//option[@value=#{newBatch.productionTime}]"

			for day in newBatch.productionDays
				client.click "//*[contains(@class,input-weekdays)]/descendant::input[@value='#{day}']"

			client
			.addValue "#input-batch-name", newBatch.name

			forEachProductInNewBatch (productInfo, lifetime, index) ->
				paths = getProductItemPaths lifetime, index, productInfo
				client.addNewProductItem productInfo, lifetime, index

			client.call callback
		
		.addCommand 'addNewProductItem', (productInfo, lifetime, productIndex, callback) ->
			paths = getProductItemPaths lifetime

			client
			.buttonClick paths.addBtn
			.pause 100
			.fillProductItem productInfo, lifetime, productIndex, callback
		
		.addCommand 'fillProductItem', (productInfo, lifetime, productIndex, callback) ->
			paths = getProductItemPaths lifetime, productIndex, productInfo

			client
			.click paths.selectInput, (err) ->
				should.not.exist err
			.click paths.validOptionInput, (err) ->
				should.not.exist err
			.addValue paths.amountInput, productInfo.amount.toString(), (err) ->
				should.not.exist err
			.call ->
				callback?()

		.addCommand 'createNewBatchAndGoBackToEditIt', (callback) ->
			client
			.fillNewBatchForm()
			.saveBatch()
			.refresh() # to ensure that is saved in db
			.gotoEditBatch newBatch.name, (err, res) ->
				should.not.exist err
				callback? err, true

		.addCommand 'validateNewBatch', (callback) ->
			client
			.getValue "#input-batch-name", (err,res) ->
		  		res.should.be.equal newBatch.name
			.getValue "#input-production-time", (err,res) ->
			 	res.should.be.equal newBatch.productionTime.toString()
			
			checkedDays = []
			for i in [1..7]
				client.getValue "//*[contains(@class,input-weekdays)]/descendant::input[#{i}]", (err,res) ->
					checkedDays.push res
			should.exist(checkedDays) && checkedDays.should.be.equal newBatch.productionDays

			client.readProductItems (err, productItems) ->
				productItems.should.containDeep newBatch.products

			.call callback

		.addCommand 'readProductItems', (callback) ->

			productItemsByTime = {}

			#Object.keys(newBatch.products).map (lifetime) ->
			for lifetime of newBatch.products
				do(lifetime) ->
					elementsAmount = 0
					client.elements "#{getProductItemPaths(parseInt(lifetime),0).controlsGroup}/descendant::select", (err,res) ->
						elementsAmount = res.value.length
					.call ->
						productItemsByTime[lifetime] = new Array elementsAmount

						[0...elementsAmount].map (productIndex) ->
							paths = getProductItemPaths parseInt(lifetime), productIndex
								
							productInfo = {}
							
							client
							.getValue paths.selectInput, (err,res) ->
								should.not.exist err
								productInfo.productId = res

								#proper way should be selecting by visiable text, but can't find a way, so selecting by value
								client.getText "#{paths.selectInput}/option[@value=\"#{res}\"]", (err,res) ->
									should.not.exist err
									productInfo.name = res.trim()
									
							.getValue paths.amountInput, (err,res) ->
								should.not.exist err
								productInfo.amount = parseInt res

							.call ->
								productItemsByTime[lifetime][productIndex]  = productInfo
								#return productInfo

			
			client.call ->
				callback? null, productItemsByTime

		#inject 6 products for each timegroup

		productsAmounts = {}
		productsAmounts[lifetime] = 6 for  lifetime, group of newBatch.products 
		client.generateAndInjectProducts productsAmounts, (err, res) ->
			newProductInfos = res.value
			for lifetime, lifetimeProducts  of newProductInfos
				for product, i in lifetimeProducts
					product.amount = newBatch.products[lifetime][i] or 20
					if i < 4 # add only 3 products to batch, keep the rest
				#replace the amount with the whole info
						newBatch.products[lifetime][i] = product
			console.log  newBatch.products


		# for lifetime of newBatch.products			
		# 	for i in [0..5]

		# 		newProdInfo = 
		# 			productId : "softproduct_#{lifetime}h_#{i}"
		# 			amount: newBatch.products[lifetime][i] or 20
		# 			name: "Soft Product #{lifetime}h #{i}"

		# 		client.injectDoc 'Products',
		# 			_id : newProdInfo.productId
		# 			name: newProdInfo.name
		# 			lifetime : parseInt(lifetime)*60
				
		# 		newProductInfos[lifetime].push newProdInfo

		# 		if i < 4 # add only 3 products to batch, keep the rest
		# 		#replace the amount with the whole info
					# newBatch.products[lifetime][i] = newProdInfo

		client.call done

	beforeEach (done) ->

		client
		#.pause 1000
		.clearSelectedTestDBEntries 'Batches'
		.relativeUrl testBaseUrl
		.pause @PAGE_LOAD_WAIT  # to allow dom to load
		#.saveScreenshot 'afterClearDB.png'
		.call done

	#TODO check also that all options in select are the same when adding several ones.
	it "displays only relevant products for each lifetimetimegroup when creating/editing a batch and correctly displays their names", (done) ->
		client
		.buttonClick '#btn-goto-create-new-batch'

		productsInOptionsCount = 0

		forEachProductInNewBatch (productInfo, lifetime, index) ->
			#check only once per lifetime group
			if index is 0
				paths = getProductItemPaths lifetime, index, productInfo

				client
				.buttonClick paths.addBtn, (err, res) ->
					should.not.exist err
				.pause 100
				.click paths.selectInput, (err, res) ->
					should.not.exist err
				.elements "#{paths.selectInput}/option[@value]", (err,res) ->
					should.not.exist err
					productsInOptionsCount += res.value.length - 1 # skip default choice element

					for elem, ind in res.value when ind isnt 0 # skip default choice element
						#check that every option has only products with specific lifetime
						client.elementIdAttribute elem.ELEMENT, "value", (err,res) ->

							client.fetchById 'Products', res.value, (err, res) ->
								should.not.exist err
								res.lifetime.should.be.equal lifetime*60

								product = res

								#check that name matches
								client.getText "#{paths.selectInput}/option[@value='#{product._id}']", (err,res) ->
									should.not.exist err
									#console.log product
									res.should.containEql product.name

		## ensure that all the products were present in <option>s
		client.call ->
			countProductsInDB = ->
				return Products.find().count()

			client.execute countProductsInDB, (err,res) ->
				productsInOptionsCount.should.be.equal res.value

		.call done


	it "creates a batch, correctly displays it, does not change the batch if no edits were made", (done) ->	
		client

		##saving spanshots	
		.buttonClick '#btn-goto-create-new-batch'		
		.saveSnapshot '#7', 'BatchNew'

		.buttonClick '#btn-cancel-edit'
		.saveSnapshot '#7', 'BatchesList'

		##creating new product and checking its values are ok

		.createNewBatchAndGoBackToEditIt()
		.saveSnapshot '#7', 'BatchEdit'

		.validateNewBatch()
		# .saveBatch() #TODO test to change something actually before save
		# .gotoEditBatch newBatch.name
		# .validateNewBatch()

		.call done

	
	it "does not save a batch, if creation is cancelled", (done) ->
		client
		.fillNewBatchForm()
		.buttonClick "#btn-cancel-edit", (err) ->
			should.not.exist err
		.waitFor "//*[text()[contains(.,\"#{newBatch.name}\")]]", 1000, (err, res) ->
			should.exist err
		.call done

	it "deletes a batch when users clicks delete button", (done) ->
		client
		.injectDoc 'Batches', newBatch,  (err,res) ->
			should.not.exist err
		.clickButtonOnBatch newBatch.name, 'btn-delete'
		.customAlertAccept()
		.waitFor "//*[text()[contains(.,\"#{newBatch.name}\")]]", 1000, (err, res) ->
			should.exist err
		.call done

	it "deletes a product in a batch when delete button is clicked", (done) ->
		lifetime = 6
		productInfosReordered = []

		#shuffling products test
		client
		.fillNewBatchForm()
		.readProductItems (err,productInfos)->
			productInfos.should.containDeep newBatch.products
			length = productInfos[lifetime].length
			productInfosReordered= productInfos[lifetime]
			for productInfo, index in productInfos[lifetime]
				do (productInfo, index) ->
					#delete product at i-th position and add it below again. Products will be same in the end but order is different
					removedProduct = (productInfosReordered.splice index,1)[0]
					productInfosReordered.push removedProduct

					client
					.buttonClick getProductItemPaths(lifetime, index).deleteBtn, (err) ->
						should.not.exist err
					.addNewProductItem removedProduct, lifetime, productInfos[lifetime].length-1, (err) ->
						should.not.exist err
					#.saveScreenshot "delete_#{index}.png"
			
		client.readProductItems (err, productInfos)->
			productInfos[lifetime].should.containDeep(productInfosReordered).and.have.lengthOf productInfosReordered.length

		#remove 2 products in the middle
		for index in [1,2]
			client
			.call ->
				productInfosReordered.splice 1,1
			.buttonClick getProductItemPaths(lifetime, 1).deleteBtn

		#add 2 new products from extra list
		
		for index in [4,5]
			do (index) ->
				client
				.call ->
					productInfosReordered.push newProductInfos[lifetime][index]
					#console.log newProductInfos[lifetime][index]

				.addNewProductItem newProductInfos[lifetime][index], lifetime, index-2
				#.saveScreenshot "add_#{index}.png"

		client
		#.saveScreenshot "added 2 extra.png"
		.readProductItems (err, productInfos)->
		 	productInfos[lifetime].should.containDeep(productInfosReordered).and.have.lengthOf productInfosReordered.length

		client.call done

	#TODO check correct order of daygroups
	it "groups batches according to production days", (done) ->
		batch = JSON.parse JSON.stringify newBatch
		batch.products = []
		dayIds = ['mon','tue','wed','thu','fri','sat','sun']
		dayNames = ['Mo','Di','Mi','Do','Fr','Sa','So']

		verifyBatchDaysGroup = (aBatch, groupTitle) ->
			client
			.injectDoc 'Batches', aBatch, (err,res) ->
				should.not.exist err
			.getText "#{getTilePath aBatch.name}/../preceding-sibling::*[1]", (err,res) ->
				should.not.exist err
				res.trim().should.be.equal groupTitle

		# each day of week
		for dayId, i in dayIds
			do(dayId, i) ->
				client.call ->
					dayName = dayNames[i]
					batch.name = "Soft Batch #{dayName}"
					batch.productionDays = [dayId]
					verifyBatchDaysGroup batch, dayName

		# weekdays
		client.call ->
			batch.name = 'Soft Batch Mon-Fri'
			batch.productionDays = dayIds.slice 0, 5
			verifyBatchDaysGroup batch, 'Mo-Fr'

		client.call ->	
			batch.name = 'Soft Batch 2 Mon-Fri'
			batch.productionDays = dayIds.slice 0, 5
			verifyBatchDaysGroup batch, 'Mo-Fr'

		#all days
		client.call ->
			batch.name = 'Soft Batch Mon-Sun'
			batch.productionDays = dayIds.slice 0, 7
			verifyBatchDaysGroup batch, dayNames.join ", "

		#mon,sun
		client.call ->
			batch.name = 'Soft Batch Mon,Sun'
			batch.productionDays = [dayIds[0], dayIds[6]]
			verifyBatchDaysGroup batch, [dayNames[0], dayNames[6]].join ", "

		#tue, thu, fri, sun
		client.call ->
			batch.name = 'Soft Batch Tue,Thu,Fri,Sun'
			batch.productionDays = [dayIds[1], dayIds[3], dayIds[4], dayIds[6]]
			verifyBatchDaysGroup batch, [dayNames[1], dayNames[3], dayNames[4], dayNames[6]].join ", "

		client.call done


	it "displays the amount of items which are inside each batch", (done) ->
		batch = JSON.parse JSON.stringify newBatch # to clone cheat
		verifyBatchAmount = (aBatch, amount) ->
			client
			.relativeUrl testBaseUrl
			.injectDoc 'Batches', aBatch, (err,res) ->
				should.not.exist err
			#.saveScreenshot "verify__#{amount}.png"
			.waitFor "#{getTilePath aBatch.name}/*[contains(@class, 'admin-batch-size')]", DB_UPDATE_WAIT
			.getText "#{getTilePath aBatch.name}/*[contains(@class, 'admin-batch-size')]", (err,res) ->
				res.should.match new RegExp "^[\\D]*#{amount}[\\D]*$"
		
		#empty batch
		client.call ->
			batch.products = []
		verifyBatchAmount batch, 0
		client.clearSelectedTestDBEntries 'Batches'

		#1 product with 0 amount
		client.call ->
			batch.products = [{ id: newProductInfos[4][0].productId, amount: 0 }]
		verifyBatchAmount batch, 0
		client.clearSelectedTestDBEntries 'Batches'

		# 1 product with amount=1
		client.call ->
			batch.products = [{ id: newProductInfos[4][0].productId, amount: 1 }]
		verifyBatchAmount batch, 1
		client.clearSelectedTestDBEntries 'Batches'

		# 1 product with amount=10000
		client.call ->
			batch.products = [{ id: newProductInfos[4][3].productId, amount: 10000 }]
		verifyBatchAmount batch, 10000
		client.clearSelectedTestDBEntries 'Batches'

		#2 products with 1 product each
		client.call ->
			batch.products= [
				{id: newProductInfos[4][0].productId, amount: 1},
				{id: newProductInfos[4][1].productId, amount: 1}
			]
		verifyBatchAmount batch, 2
		client.clearSelectedTestDBEntries 'Batches'

		#all test products with different amounts
		count = 0
		client.call ->
			batch.products = []
			for lifetime, lifetimeGroup of newProductInfos
				for productInfo, index in lifetimeGroup
					#console.log productInfo
					amount = parseInt(lifetime)+index
					batch.products.push 
						id: productInfo.productId
						amount: amount
					count += amount
			
			verifyBatchAmount batch, count

		client.call done


	it "displays production time of each batch"

	it "saves creation time of the batch and keeps the time if edited"



	after (done) ->
		client
		.clearTestDBEntries()
		.call done

describe "more tests", ->